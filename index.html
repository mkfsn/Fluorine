<h1>Fluorine: a context based Javascript library</h1>

<p>Fluorine is a Javascript library and eDSL, want to help developers constructing their 
application with more functional features, and build large programs from small functions.
It currently has these features:</p>

<ul>
<li>Allow to isolate impure parts in the program.</li>
<li>Still allow mixing pure/impure parts when necessary.</li>
<li>Flow-control, to avoid callback hell.</li>
<li>(Sort of) laziness.</li>
<li>(Partially) typed.</li>
</ul>

<p>It's first inspired by the <a href="http://www.cs.umd.edu/projects/PL/arrowlets/api-arrowlets.xhtml">Arrowlets</a> library, 
which brought functional structure, the Arrowlet, into Javascript world. Of course, the great <a href="http://jquery.com/">jQuery</a> 
and <a href="http://underscorejs.org/">Underscore.js</a> also shown how amazingly Javascript could be.</p>

<p>Futhurmore, this library also want to experiment the possibility of constructing reasonable Javascript programs 
<strong>without (too much) class, object and other OOP things</strong>. Because Javascript, at least according to Douglas Crockford, 
<a href="http://www.crockford.com/javascript/javascript.html">"has more in common with functional languages like Lisp or Scheme than with C or Java".</a>
This is a good point in this age of OOP-mainstreaming, especailly most of libraries are all eager to provide class, inheritance and other OOP stuffs.</p>

<h2>Features</h2>

<h3>Isolate Impure Parts in Javascript Applications</h3>

<p>Fluorine can help Javascript programmers isolate impure parts in their applications, 
so that errors resulted from side-effects can be reduced as much as possible:</p>

<pre><code>fluorine.infect()

// Impure function: directly manipulate DOMs in the document.
// All impure computing should be wrapped with contexts.
//
// :: String -&gt; UI ()
drawMyName = function(name)
{
    return UI('#name-user').$().text(name).done()
}

// Pure function: return a plain old string.
//
// :: String 
giveName = function()
{
    return "foobar"
}
</code></pre>

<p>Programmers can still mix them in some proper ways, like in a generator function 
returing yet another larger context:</p>

<pre><code>// :: UI ()
drawApp = function()
{
    return UI().
        let(giveName).as('name').
        tie( function()
        {
            // Use them just like "let" in other languages.
            var slc_ex1 = '#ex1'
            return UI("&lt;div id='name-user'&gt;&lt;/div&gt;").$().appendTo('#ex1').done()
        }).
        tie( function()
        {   
            // Fetch the value pre-defined by `let` and `as`.
            return drawMyName(this.name)
        }).
        done()
}
</code></pre>

<h3>Break the Glass in Emergency</h3>

<p>Basically, pure functions and values now can't arbitrarily mix with impure things:</p>

<pre><code>// :: String
pureString = function()
{
    return "pure"
}

// :: UI String
impureString = function()
{
    return UI("impure").done() 
}

illegal_string = pureString() + impureString()  // Error.
</code></pre>

<p>But in some special cases, we can still do that if the context come with some extractor functions:</p>

<pre><code>illegal_string = pureString() + impureString()().extract()  // UI String -&gt; String
</code></pre>

<p>Also, we can do some dirty things in the theoretically pure combinator, like the <code>let</code> or <code>_</code>:</p>

<pre><code>UI('#name-user').$().
    _(function(e)
    {
        // Should keep pure, not violent that like this:

        $(e).text("name changed !")
    }).
    done()
</code></pre>

<p>This is sometime useful because we may want to embedded 3rd libraries in our contexts.</p>

<p>Nevertheless, these tricks should be exceptions, not normalities.</p>
