// Generated by CoffeeScript 1.3.3
(function() {

  self.fluorine = self.fluorine || {};

  fluorine.Process = function() {
    return new fluorine.Process.o();
  };

  fluorine.Process.o = function() {
    this.__result = null;
    this.__queue = [];
    this.__recycle_queue = [];
    return this;
  };

  fluorine.Process.o.prototype.next = function(fn) {
    return this.__queue.push(fn);
  };

  fluorine.Process.o.prototype.concat = function(proc) {
    return this.__queue = this.__queue.concat(proc.__queue);
  };

  fluorine.Process.o.prototype.preconcat = function(proc) {
    return this.__queue = proc.__queue.concat(this.__queue);
  };

  fluorine.Process.o.prototype.run = function(result) {
    var i, __fn;
    if (2 <= arguments.length) {
      this.__result = [];
      for (i in arguments) {
        this.__result.push(arguments);
      }
    } else {
      this.__result = result;
    }
    if (0 === this.__queue.length) {
      return;
    }
    __fn = this.__queue.shift();
    this.__recycle_queue.push(__fn);
    return __fn.apply({}, arguments);
  };

  fluorine.Process.o.prototype.refresh = function() {
    while (0 !== this.__queue.length) {
      this.__recycle_queue.push(this.__queue.shift());
    }
    this.__queue = this.__recycle_queue;
    return this.__recycle_queue = [];
  };

  fluorine.Process.o.prototype.extract = function() {
    return this.__result;
  };

  /*
  -- Programmer's Hidden Notes --
  
  Actions(proc)   -- 表示此 action chain 在哪個 proc 內
  .action()       -- 其他 action 都只需要把自己的執行函式推入 proc 中
  -- 而這個執行函式中有一段是去 call 下一個 proc 內的執行函式
  -- 用 proc.run() 去執行
  .actionAsync()  -- 到這邊，把自己內部的 proc 設定在 callback 內。
  -- callback 會在執行階段被執行。屆時，他會繼續去執行剩下的 proc actions.
  -- 因此，剩下的部份只有在經過了 callback 時才會被執行
  --
  -- 執行 async 動作
  -- callback：中間有一段是執行 proc.run()
  .action()
  .action();
  */


}).call(this);
